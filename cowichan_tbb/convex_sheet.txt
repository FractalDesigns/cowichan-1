/**
 * Computes the convex hull of a set of points, returning a set of points in
 * counter-clockwise order. The method used is known as parallel quickhull, and
 * it is described at:
 * 
 * http://www.cs.cmu.edu/~scandal/cacm/node10.html
 *
 * The code used in this program is based on the ideas presented there.
 */

real cross(Point& l1, Point& l2, Point& p) {
	return (l1.x - p.x) * (l2.y - p.y) -
		   (l1.y - p.y) * (l2.x - p.x);
}

void split(vector<Point>& hull, vector<Point>& points, int p1, int p2) {

	int maxIndex = -1;
	real maxCross = -inf;
	
	// compute the farthest point from the line, in the positive half-space
	for (int i = 0; i < points.size(); ++i) {
		real currentCross = cross(points[p1], points[p2], points[i]);
		if (currentCross > maxCross) {
			maxIndex = i;
			maxCross = currentCross;
		}
	}
	
	// is the farthest point on the right side?
	// if so, we must recurse based on that point.
	if (maxCross > 0.0) {
		
		split(hull, points, p1, maxIndex);
		split(hull, points, maxIndex, p2);
		return;
		
	} 
	
	// otherwise, it's not on the right side; we don't need to split anymore.
	// this is because all points are inside the hull when we use this half-space.
	// add the first point and return.
	hull.push_back(points[p1]);	
	
}

vector<Point> convexHull(vector<Point>& points) {
	
	vector<Point> hull;
	
	// figure out the points with minimum and maximum x values
	int minIndex = 0, maxIndex = 0;
	for (size_t i = 1; i < SIZE; ++i) {
		
		if (points[minIndex].x > points[i].x) minIndex = i;
		if (points[maxIndex].x < points[i].x) maxIndex = i;
		
	}
	
	// use these as initial pivots
	split(hull, points, p1, p2);
	split(hull, points, p2, p1);
	
	// return the points that we figured out
	return hull;
	
}

