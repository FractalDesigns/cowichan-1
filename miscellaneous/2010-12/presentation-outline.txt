Questions to ponder:
* What does the audience know already?
* What does the audience want to know?
* What surprising insights can we give to them?


What is Erlang?
* Related languages in paradigm: ML and Haskell, explicit messaging (Alef, Newsqueak, sockets)
* Function calls and recursion
* Pattern matching
* Dynamically typed
* No global variables
* Higher-order functions (not a highlight)
* Major value types: Atoms, numbers, tuples, lists, PIDs
* Asynchronous messaging (CSP-like)
* No need to marshall messages
* VM-based, distributed, heterogeneous

What is Erlang not?
* Shared memory communication
* Heavy numerical computation
* Arrays whatsoever
* String handling
* Automatic distribution, load balance, fault recovery

Code examples?
* Pattern matching and recursion
* Spawning processes
* Messaging
* Recovery?

Case studies
* Game of Life
  * Reading neighbouring cells is awkward
  * Distributed fault-tolerance: Hard to save and restore state
* Mandelbrot set
  * Easy to compute
  * Easy to parallelize, no peer-to-peer communication
  * Imbalanced workload
  * Easy to recover from
  * Live demo?
* Sorting with sample sort (Colin)
  * (...Fill in details...)

Debugging Erlang (Colin)
* (...Fill in details...)

How does Erlang help HPC and distributed computing?
* ... It doesn't?
* Erlang for control, C for computation?

Overall
* Significantly different programming style than C
* No tools for numerical algorithms
* No easy looping
* Need to explicitly pass state everywhere - between functions, to other processes