Questions to ponder:
* What does the audience know already?
* What does the audience want to know?
* What surprising insights can we give to them?


What is Erlang?
* Related languages in paradigm: ML and Haskell, explicit messaging (Alef, Newsqueak, sockets)
* Function calls and recursion
* Pattern matching
* Dynamically typed
* No global variables
* Single assignment
* Higher-order functions (not a highlight)
* Major value types: Atoms, numbers, tuples, lists, PIDs
* Asynchronous messaging (CSP-like)
* No need to marshall messages
* VM-based, distributed, heterogeneous
* Typical uses (telecom, instant messaging

What is Erlang not?
* Shared memory communication
* Heavy numerical computation
* Arrays whatsoever
* String handling
* Automatic distribution, load balance, fault recovery

Fault Tolerance:
* Our principal goal being to attempt fault tolerant parallel implementations of some Cowichan problems in Erlang
* Erlang's approach to fault-tolerance
* Stuff we tried, or thought about: timeouts, monitors, leases, Mnesia...
* Our finding that problems that are easy to parallelize may or may not be easy to make fault tolerant
* How do we characterize problems that are hard to make fault tolerant?

Code examples?
* Pattern matching and recursion
* Spawning processes
* Messaging
* Scatter and gather, timeouts
* Recovery?

Case studies
* Game of Life
  * Reading neighbouring cells is awkward
  * Distributed fault-tolerance: Hard to save and restore state
* Mandelbrot set
  * Easy to compute
  * Easy to parallelize, no peer-to-peer communication
  * Imbalanced workload
  * Easy to recover from
  * Live demo?
* Sorting with sample sort
  * A distributed divide-and-conquer sorting algorithm with distinct stages
  * Fault recovery options. Restarting the whole computation, or checkpointing after the first stage. Hard to do anything more fine-grained?

Debugging Erlang
* Erlang comes with a nice visual debugger 
* Makes it easy to visualize the flow of a program, to debug specific processes, inspect variables, etc.

How does Erlang help HPC and distributed computing?
* ... It doesn't?
* Erlang for control, C for computation?

Overall
* Significantly different programming style than C
* No tools for numerical algorithms
* No easy looping
* Need to explicitly pass state everywhere - between functions, to other processes
